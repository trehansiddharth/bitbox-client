#!python3

import time
from typing import Optional, Callable
import typer
import getpass
import requests
import os
import random
import string
import json
import hashlib
import keyring
from dataclasses import dataclass, asdict
import binascii
from Crypto.Cipher import PKCS1_OAEP
from Crypto.PublicKey import RSA
import cryptocode
import re
from rich.console import Console
from rich.table import Table
from rich.prompt import Confirm, Prompt
from datetime import datetime
from otc import otcDict

BITBOX_HOST = "localhost:8000"
BITBOX_CONFIG_FOLDER = os.path.join(os.getcwd(), ".bitbox")
BITBOX_CLIENT_NAME_LENGTH = 10
BITBOX_STATUS_OK = 200
BITBOX_FILE_KEY_LENGTH = 128
BITBOX_FILENAME_REGEX = r"^@[a-z0-9]+\/[^\/\r\n ]+$"

BITBOX_ERR_AUTHENTICATION_FAILED = "authentication-failed"

app = typer.Typer()
console = Console()

@dataclass
class UserInfo:
  username: str
  clientCreated: int
  publicKeyPath: str
  encryptedPrivateKeyPath: str

PersonalKey = str
Session = str

@dataclass
class FileInfo:
  fileId: str
  name: str
  owner: str
  bytes: int
  lastModified: int
  encryptedKey: str

def getPersonalKeyFromPassword(password: str) -> str:
  return hashlib.sha256(password.encode("utf-8")).hexdigest()

def getPersonalKey() -> str:
  personalKeyFromKeyring = keyring.get_password("bitbox", "personalKey")
  if personalKeyFromKeyring is None:
    password = getpass.getpass("Password: ")
    personalKey = getPersonalKeyFromPassword(password)
    keyring.set_password("bitbox", "personalKey", personalKey)
    return personalKey
  else:
    return personalKeyFromKeyring

def getUserInfo() -> Optional[UserInfo]:
  userInfoPath = os.path.join(BITBOX_CONFIG_FOLDER, "userinfo.json")
  if (not os.path.exists(userInfoPath)):
    return None
  with open(os.path.join(BITBOX_CONFIG_FOLDER, "userinfo.json"), "r") as f:
    userInfoJSON = f.read()
  return UserInfo(**json.loads(userInfoJSON))

def getPublicKey(userInfo: UserInfo) -> RSA.RsaKey:
  with open(os.path.join(BITBOX_CONFIG_FOLDER, userInfo.publicKeyPath), "r") as f:
    publicKey = f.read()
  return RSA.import_key(publicKey)

def getPrivateKey(userInfo: UserInfo, personalKey: str) -> RSA.RsaKey:
  with open(os.path.join(BITBOX_CONFIG_FOLDER, userInfo.encryptedPrivateKeyPath), "r") as f:
    encryptedPrivateKey = f.read()
  decryptedPrivateKey = cryptocode.decrypt(encryptedPrivateKey, personalKey)
  return RSA.import_key(decryptedPrivateKey)

def rsaEncrypt(data: bytes, publicKey: RSA.RsaKey) -> bytes:
  cipher = PKCS1_OAEP.new(publicKey)
  return cipher.encrypt(data)

def rsaDecrypt(data: bytes, privateKey: RSA.RsaKey) -> bytes:
  cipher = PKCS1_OAEP.new(privateKey)
  return cipher.decrypt(data)

def humanReadableFilesize(bytes: int) -> str:
  if bytes < 1024:
    return f"{bytes} B"
  elif bytes < 1024 ** 2:
    return f"{bytes / 1024:.1f} KiB"
  elif bytes < 1024 ** 3:
    return f"{bytes / 1024 ** 2:.1f} MiB"
  else:
    return f"{bytes / 1024 ** 3:.1f} GiB"

def humanReadableJSTimestamp(timestamp: int) -> str:
  return datetime.utcfromtimestamp(timestamp / 1000).strftime('%Y-%m-%d %H:%M:%S')

def authenticateUser(userInfo: UserInfo, personalKey: str) -> str:
  privateKey = getPrivateKey(userInfo, personalKey)

  challengeBody = {
    "username": userInfo.username
  }
  challengeResponse = requests.post(
    f"http://{BITBOX_HOST}/api/auth/login/challenge",
    json=challengeBody)
  if challengeResponse.status_code != BITBOX_STATUS_OK:
    raise Exception(challengeResponse.text)
  challenge = challengeResponse.text
  
  challengeBytes = bytearray.fromhex(challenge)
  answerBytes = rsaDecrypt(challengeBytes, privateKey)
  answer = binascii.hexlify(answerBytes).decode("utf-8")

  loginBody = {
    "username": userInfo.username,
    "challengeResponse": answer
  }
  loginResponse = requests.post(
    f"http://{BITBOX_HOST}/api/auth/login/login",
    json=loginBody)
  if loginResponse.status_code != BITBOX_STATUS_OK:
    raise Exception(loginResponse.text)
  return loginResponse.headers['set-cookie']

def loginUser() -> tuple[UserInfo, Session]:
  userInfo = getUserInfo()
  if userInfo is None:
    console.print("Bitbox has not been configured on this machine.\n")
    console.print("[bold]HINT: Run `bitbox setup` to register or login to Bitbox.[/bold]")
    raise typer.Exit(code=1)
  session = keyring.get_password("bitbox", "session")
  if session is None:
    personalKey = getPersonalKey()
    session = authenticateUser(userInfo, personalKey)
    keyring.set_password("bitbox", "session", session)
  return userInfo, session

def attemptWithSession(f: Callable[[Session], requests.Response], session: Session, userInfo: UserInfo, personalKey: Optional[PersonalKey] = None) -> requests.Response:
  response = f(session)
  if (response.status_code != BITBOX_STATUS_OK):
    if response.text == BITBOX_ERR_AUTHENTICATION_FAILED:
      if personalKey is None:
        personalKey = getPersonalKey()
      session = authenticateUser(userInfo, personalKey)
      keyring.set_password("bitbox", "session", session)
      response = f(session)
      if (response.status_code != BITBOX_STATUS_OK):
        raise Exception(response.text)
    else:
      raise Exception(response.text)
  return response

@app.command(short_help="Set up bitbox under a new or existing user")
def setup():
  if os.path.exists(os.path.join(BITBOX_CONFIG_FOLDER, "userinfo.json")):
    console.print(f"You've already set up bitbox on this machine! To reconfigure bitbox, delete {BITBOX_CONFIG_FOLDER} and try again.\n")
    console.print("[bold]WARNING: This will delete your previous keys. It may be wise to move this folder to a different location.[/bold]", style="red")
    raise typer.Exit(code=1)

  console.print("\n[bold]Welcome to Bitbox![/bold] Bitbox is an end-to-end encrypted file storage, sharing, and synchronization tool for busy developers. Let's get you set up.\n")
  
  newUser = Confirm.ask("Are you a new Bitbox user?")
  if newUser:
    registerUser()
  else:
    registerClient()

def registerUser():
  userExists = True
  while userExists:
    username = Prompt.ask("[bold]Pick a username.[/bold] This will identify you to other Bitbox users")
    userInfo = requests.post(f"http://{BITBOX_HOST}/api/info/user", json={ "username" : username })
    if userInfo.status_code == BITBOX_STATUS_OK:
      console.print("That username is already taken!", style="red")
    else:
      userExists = False

  password = Prompt.ask("[bold]Pick a password.[/bold] This will be used to unlock your private key on configured machines", password=True)
  passwordConfirm = Prompt.ask("Confirm password", password=True)
  if password != passwordConfirm:
    console.print("Passwords do not match!")
    raise typer.Exit(code=1)
  # TODO: additional password validation
  
  personalKey = getPersonalKeyFromPassword(password)

  privateKey = RSA.generate(2048)
  publicKey = privateKey.publickey()
  publicKeyStr = publicKey.export_key().decode("utf-8")
  privateKeyStr = privateKey.export_key().decode("utf-8")
  encryptedPrivateKey = cryptocode.encrypt(privateKeyStr, personalKey)

  userInfo = UserInfo(
    username=username,
    clientCreated=int(time.time() * 1000),
    publicKeyPath=f"{username}.key.public",
    encryptedPrivateKeyPath=f"{username}.key.private.encrypted")

  registerUserBody = {
    "username": username,
    "publicKey": publicKeyStr,
    "encryptedPrivateKey": encryptedPrivateKey
  }
  registerUserResponse = requests.post(f"http://{BITBOX_HOST}/api/auth/register/user", json=registerUserBody)

  if (registerUserResponse.status_code == BITBOX_STATUS_OK):
    keyring.set_password("bitbox", "personalKey", personalKey)
    with open(os.path.join(BITBOX_CONFIG_FOLDER, f"{username}.key.public"), "w") as f:
      f.write(publicKeyStr)
    with open(os.path.join(BITBOX_CONFIG_FOLDER, f"{username}.key.private.encrypted"), "w") as f:
      f.write(encryptedPrivateKey)
    with open(os.path.join(BITBOX_CONFIG_FOLDER, f"userinfo.json"), "w") as f:
      userInfoJSON = json.dumps(asdict(userInfo), indent=2)
      f.write(userInfoJSON)
    session = authenticateUser(userInfo, personalKey)
    keyring.set_password("bitbox", "session", session)
    console.print("\n[green]You've been successfully registered on BitBox! You can now use Bitbox to store, share, and sync files.[/green]")
  else:
    typer.echo("Failed to register user!")
    typer.echo(registerUserResponse.text)
    raise typer.Exit(code=1)

def registerClient():
  username = Prompt.ask("Username")
  password = Prompt.ask("Password", password=True)
  personalKey = getPersonalKeyFromPassword(password)

  otcValid = False
  console.print("\nFrom a machine that has already been configured with Bitbox, run `bitbox otc` to generate a one-time-code. This is a phrase of 4 words. Enter that code below.")
  while not otcValid:
    otcWords = Prompt.ask("Code (case-insensitive)")
    otcDictInv = {v.lower(): k for k, v in otcDict.items()}
    otc = ""
    for otcWord in otcWords.split():
      if otcWord.lower() in otcDictInv.keys():
        otc += otcDictInv[otcWord.lower()].lower()
      else:
        console.print(f"Your code was invalid. Try again with a new code.", style="red")
        break
    else:
      otcValid = True

  recoverKeysBody = {
    "username": username,
    "otc": otc
  }
  recoverKeysResponse = requests.post(f"http://{BITBOX_HOST}/api/auth/recover/recover-keys", json=recoverKeysBody)

  if (recoverKeysResponse.status_code == BITBOX_STATUS_OK):
    encryptedPrivateKey = recoverKeysResponse.text
    privateKeyStr = cryptocode.decrypt(encryptedPrivateKey, personalKey)
    privateKey = RSA.import_key(privateKeyStr)
    publicKey = privateKey.publickey()
    userInfo = UserInfo(
      username=username,
      clientCreated=int(time.time() * 1000),
      publicKeyPath=f"{username}.key.public",
      encryptedPrivateKeyPath=f"{username}.key.private.encrypted")
    keyring.set_password("bitbox", "personalKey", personalKey)
    with open(os.path.join(BITBOX_CONFIG_FOLDER, f"{username}.key.public"), "w") as f:
      f.write(publicKey.export_key().decode("utf-8"))
    with open(os.path.join(BITBOX_CONFIG_FOLDER, f"{username}.key.private.encrypted"), "w") as f:
      f.write(encryptedPrivateKey)
    with open(os.path.join(BITBOX_CONFIG_FOLDER, f"userinfo.json"), "w") as f:
      userInfoJSON = json.dumps(asdict(userInfo), indent=2)
      f.write(userInfoJSON)
    session = authenticateUser(userInfo, personalKey)
    keyring.set_password("bitbox", "session", session)
    console.print("\n[green]You've successfully logged into BitBox! You can now use Bitbox to store, share, and sync files on this machine.[/green]")
  else:
    typer.echo("Failed to register client!")
    typer.echo(recoverKeysResponse.text)
    raise typer.Exit(code=1)

@app.command(short_help="Add a file to your bitbox")
def add(file: str):
  userInfo, session = loginUser()

  with open(file, "r") as f:
    fileContents = f.read()
  
  publicKey = getPublicKey(userInfo)
  fileKey = ''.join(random.choices(string.ascii_lowercase, k=BITBOX_FILE_KEY_LENGTH))
  
  encryptedFileBytes = cryptocode.encrypt(fileContents, fileKey).encode("utf-8")

  prepareSendBody = {
    "recipients": [],
    "bytes": len(encryptedFileBytes),
    "filename": os.path.basename(file)
  }
  prepareSendResponse = attemptWithSession(
    lambda session: requests.post(f"http://{BITBOX_HOST}/api/storage/prepare-send",
      headers={"Cookie": session},
      json=prepareSendBody),
    session, userInfo)
  
  uploadURL = prepareSendResponse.json()["uploadURL"]
  resumableSession = requests.post(uploadURL, "", headers={
      "x-goog-resumable": "start",
      "content-type": "text/plain",
      "x-goog-content-length-range": f"0,{len(encryptedFileBytes)}"
  })
  if resumableSession.status_code != 201:
    typer.echo(resumableSession.text)
    raise typer.Exit(code=1)
  
  location = resumableSession.headers["location"]
  uploadResponse = requests.put(location, data=encryptedFileBytes, headers={
    "content-type": "text/plain",
    "content-length": str(len(encryptedFileBytes))
  })
  if uploadResponse.status_code != 200:
    typer.echo(uploadResponse.text)
    raise typer.Exit(code=1)
  
  fileId = prepareSendResponse.json()["fileId"]
  personalEncryptedKey = rsaEncrypt(fileKey.encode("utf8"), publicKey)
  personalEncryptedKeyHex = binascii.hexlify(personalEncryptedKey).decode("utf-8")
  sendBody = {
    "fileId": fileId,
    "personalEncryptedKey": personalEncryptedKeyHex,
    "recipientEncryptedKeys": {}
  }
  attemptWithSession(
    lambda session: requests.post(f"http://{BITBOX_HOST}/api/storage/send",
      headers={"Cookie": session},
      json=sendBody),
    session, userInfo)
  typer.echo(f"{file} has been added to your bitbox.")

@app.command(short_help="Clone a file from your bitbox onto your local machine")
def clone(file: str):
  userInfo, session = loginUser()
  personalKey = getPersonalKey()

  if (re.match(BITBOX_FILENAME_REGEX, file)):
    splitFile = file.split("/")
    filename = splitFile[1]
    saveBody = {
      "owner": splitFile[0],
      "filename": filename
    }
  else:
    filename = file
    saveBody = {
      "filename": filename
    }

  saveResponse = attemptWithSession(
    lambda session: requests.post(f"http://{BITBOX_HOST}/api/storage/save",
      headers={"Cookie": session},
      json=saveBody),
    session, userInfo)
  downloadURL = saveResponse.json()["downloadURL"]
  encryptedKey = saveResponse.json()["encryptedKey"]

  downloadResponse = requests.get(downloadURL)
  if downloadResponse.status_code != 200:
    typer.echo(downloadResponse.text)
    raise typer.Exit(code=1)
  
  downloadFileContents = downloadResponse.text
  privateKey = getPrivateKey(userInfo, personalKey)
  decryptedFileKey = rsaDecrypt(binascii.unhexlify(encryptedKey), privateKey)
  filekey = decryptedFileKey.decode("utf-8")
  fileContents = cryptocode.decrypt(downloadFileContents, filekey)

  with open(filename, "w") as f:
    f.write(fileContents)

  typer.echo(f"{file} has been cloned to your local machine as {filename}.")

@app.command(short_help="Delete a file from your bitbox")
def delete(file: str):
  userInfo, session = loginUser()
  deleteBody = {
    "filename": file
  }
  deleteResponse = attemptWithSession(
    lambda session: requests.post(f"http://{BITBOX_HOST}/api/storage/delete",
      headers={"Cookie": session},
      json=deleteBody),
    session, userInfo)
  typer.echo(f"{file} has been deleted from your bitbox.")

@app.command(short_help="List all files in your bitbox")
def files():
  userInfo, session = loginUser()
  filesResponse = attemptWithSession(
    lambda session: requests.get(f"http://{BITBOX_HOST}/api/info/files",
      headers={"Cookie": session},
      json={}),
    session, userInfo)
  filesInfo : list[FileInfo] = [FileInfo(**fileInfo) for fileInfo in filesResponse.json()]

  table = Table()
  table.add_column("Filename")
  table.add_column("Size")
  table.add_column("Last Modified (GMT)")
  for fileInfo in filesInfo:
    if fileInfo.owner != userInfo.username:
      filename = f"@{fileInfo.owner}/{fileInfo.name}"
    else:
      filename = fileInfo.name
    table.add_row(filename, humanReadableFilesize(fileInfo.bytes), humanReadableJSTimestamp(fileInfo.lastModified))
  console.print(table)

@app.command(short_help="Generate a one-time-code to setup Bitbox on another machine")
def otc():
  userInfo, session = loginUser()
  otcResponse = attemptWithSession(
    lambda session: requests.get(f"http://{BITBOX_HOST}/api/auth/recover/generate-otc",
      headers={"Cookie": session}),
    session, userInfo)
  otc = otcResponse.text
  otcWords = [otcDict[otc[i:i+2].upper()].lower() for i in range(0, len(otc), 2)]
  console.print(f"[bold]Your one-time-code is:[/bold] [green]{' '.join(otcWords)}[/green]\n")
  console.print("Enter this code on the machine you want to set up a new Bitbox client on.")

@app.callback(invoke_without_command=True)
def main(ctx: typer.Context):
  if ctx.invoked_subcommand is not None:
    return

  userInfo, session = loginUser()
  console.print(f"You are logged in as: {userInfo.username}")
  console.print(f"")
  filesResponse = attemptWithSession(
    lambda session: requests.get(f"http://{BITBOX_HOST}/api/info/files",
      headers={"Cookie": session},
      json={}),
    session, userInfo)
  filesInfo : list[FileInfo] = [FileInfo(**fileInfo) for fileInfo in filesResponse.json()]

  table = Table()
  table.add_column("Filename")
  table.add_column("Size")
  table.add_column("Last Modified (GMT)")
  for fileInfo in filesInfo:
    if fileInfo.owner != userInfo.username:
      filename = f"@{fileInfo.owner}/{fileInfo.name}"
    else:
      filename = fileInfo.name
    table.add_row(filename, humanReadableFilesize(fileInfo.bytes), humanReadableJSTimestamp(fileInfo.lastModified))
  console.print(table)
  console.print("")
  bytesUsed = sum([fileInfo.bytes for fileInfo in filesInfo])
  console.print(f"Total space usage: {humanReadableFilesize(bytesUsed)} / 1 GiB ({bytesUsed / 1073741824 :.0%})")

if __name__ == "__main__":
  try:
    os.makedirs(BITBOX_CONFIG_FOLDER)
  except FileExistsError:
    pass

  app()